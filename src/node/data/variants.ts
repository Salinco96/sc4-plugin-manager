import type { AssetID } from "@common/assets"
import type { AuthorID } from "@common/authors"
import type { TGI } from "@common/dbpf"
import type { ExemplarDataPatch } from "@common/exemplars"
import type { Requirements } from "@common/options"
import { type PackageID, getOwnerId, isNew } from "@common/packages"
import type { MMPData, PackageWarning } from "@common/types"
import { type MaybeArray, parseStringArray } from "@common/utils/types"
import type { DependencyInfo, VariantAssetInfo, VariantID, VariantInfo } from "@common/variants"
import { type BuildingData, loadBuildingInfo } from "./buildings"
import { type FamilyData, loadFamilyInfo } from "./families"
import { type LotData, loadLotInfo } from "./lots"
import { type OptionData, loadOptionInfo } from "./options"
import { type PropData, loadPropInfo } from "./props"

import type { BuildingID } from "@common/buildings"
import { type Categories, CategoryID } from "@common/categories"
import type { FamilyID } from "@common/families"
import type { LotID } from "@common/lots"
import type { PropID } from "@common/props"
import { toPosix } from "@node/files"
import {
  generate,
  isEmpty,
  isString,
  mapDefined,
  mapValues,
  union,
  unionBy,
  unique,
} from "@salinco/nice-utils"
import type { AssetData } from "./assets"
import { loadCategories } from "./categories"
import type { PackageData } from "./packages"

/**
 * Raw variant data, as stored in YAML files
 *
 * Once published, this should be kept backward-compatible.
 */
export interface VariantData extends ContentsData {
  /**
   * List of required assets (and additional details about included files)
   *
   * Only on remote packages.
   */
  assets?: Array<AssetID | VariantAssetData>

  authors?: MaybeArray<AuthorID>

  category?: MaybeArray<string>

  credits?: {
    [authorId in AuthorID]?: string | null
  }

  /**
   * List of required dependencies
   *
   * - These packages **must not** contain `features` (use {@link requirements} instead)
   * - Dependency on a specific variant is **not** supported
   * - Partial dependencies are supported
   */
  dependencies?: Array<PackageID | DependencyInfo>

  /**
   * Whether this package or variant is experimental (e.g. test version)
   */
  deprecated?: boolean | PackageID

  /**
   * Full description in Markdown format
   *
   * The following sections should not be included in the description:
   *   - greetings (the top of the description is most visible part so it should be informative)
   *   - {@link name} (redundant)
   *   - {@link credits}
   *   - {@link dependencies}
   *   - {@link optional} dependencies
   *   - {@link thanks}
   *   - listing or detailed stats of {@link lots}, {@link props}...
   *   - compatibility information redundant with {@link requirements}
   *   - installation/uninstallation instructions redundant with {@link warnings}
   *   - redirections to included {@link readme} file, {@link support} thread, or Git {@link repository}
   */
  description?: string

  /**
   * Whether this package or variant should be hidden in Manager (e.g. work in progress)
   */
  disabled?: boolean

  /**
   * Whether this package or variant is experimental (e.g. test version)
   */
  experimental?: boolean

  /**
   * List of installed files
   *
   * Only on installed/local packages.
   */
  files?: FileData[]

  /**
   * List of image URLs
   */
  images?: string[]

  /**
   * Date or ISO string at which this variant was last generated/updated by the Indexer (used by Indexer only)
   */
  lastGenerated?: Date | string

  /**
   * Date or ISO string at which this variant was last modified/uploaded, as specified on its download page
   */
  lastModified?: Date | string

  /**
   * Name of the .log file generated by this variant's DLL, if any
   */
  logs?: string

  mmps?: MMPData[]

  /**
   * Pretty name for this variant
   */
  name?: string

  /**
   * List of optional dependencies
   *
   * - Contrary to {@link dependencies}, these packages may contain `features`
   */
  optional?: PackageID[]

  /**
   * List of options
   */
  options?: OptionData[]

  /**
   * Relative path to the main Readme file (the one that is shown in Readme tab)
   */
  readme?: string

  /**
   * Date or ISO string at which this variant was first added to the Manager database (used to mark "new" packages)
   */
  release?: Date | string

  /**
   * URL to this package's source code repository
   */
  repository?: string

  requirements?: Requirements

  /**
   * Shorter description, containing no line breaks or formatting, displayed instead of {@link description} when space is limited (e.g. package listing)
   */
  summary?: string

  /**
   * URL to a plugin/support thread
   */
  support?: string

  thanks?: {
    [authorId in AuthorID]?: string | null
  }

  /**
   * URL to a thumbnail
   */
  thumbnail?: string

  /**
   * URL to this package's main download page
   */
  url?: string

  /**
   * Valid semver version (x.x.x)
   */
  version?: string

  /**
   * Warnings
   */
  warnings?: PackageWarning[]
}

export interface ContentsData {
  /**
   * Included building family exemplars, grouped by file and instance ID
   */
  buildingFamilies?: {
    [path in string]?: {
      [familyId in FamilyID]?: FamilyData
    }
  }

  /**
   * Included building exemplars, grouped by file and instance ID
   */
  buildings?: {
    [path in string]?: {
      [instanceId in BuildingID]?: BuildingData
    }
  }

  /**
   * Included lot exemplars, grouped by file and instance ID
   */
  lots?: {
    [path in string]?: {
      [instanceId in LotID]?: LotData
    }
  }

  /**
   * Included S3D model IDs, grouped by file
   */
  models?: {
    [path in string]?: string[]
  }

  /**
   * Included prop family exemplars, grouped by file and instance ID
   */
  propFamilies?: {
    [path in string]?: {
      [familyId in FamilyID]?: FamilyData
    }
  }

  /**
   * Included prop exemplars, grouped by file and instance ID
   */
  props?: {
    [path in string]?: {
      [instanceId in PropID]?: PropData
    }
  }

  /**
   * Included FSH texture IDs, grouped by file
   */
  textures?: {
    [path in string]?: string[]
  }
}

export interface DependencyData {
  /**
   * Package ID
   */
  id: PackageID

  /**
   * Paths to include (glob patterns)
   *
   * By default, the whole package is included.
   */
  include?: string[]

  /**
   * Whether to include this dependency's dependencies, recursively
   *
   * Defaults to `true` unless {@link include} is specified.
   */
  transitive?: boolean
}

export interface FileData {
  /**
   * Mapping to a new path upon installation
   *
   * Only on remote packages.
   */
  as?: string

  /**
   * Conditions for this file to be included
   */
  condition?: Requirements

  /**
   *
   * Only on installed packages.
   */
  patches?: {
    [entryId in TGI]?: ExemplarDataPatch
  }

  /**
   * Relative path
   *
   * - For remote packages, this may be a glob pattern, including condition replacements
   * - For installed packages, this must be an exact path (POSIX preferred but not required)
   */
  path: string

  /**
   * If this file should have a higher priority than the rest of the package, overwrite here.
   *
   * - Priority of 900 or higher is treated as "override"
   */
  priority?: number
}

export interface VariantAssetData extends AssetData {
  /**
   * List of cleanitol paths (glob patterns)
   *
   * - By default, all txt files with containing "cleanitol" are included.
   * - If specified, *only* the provided paths are included.
   */
  cleanitol?: string[]

  /**
   * List of documentation paths (glob patterns)
   *
   * - By default, all txt/pdf/html/css and image files are included.
   * - If specified, *only* the provided paths are included.
   */
  docs?: Array<string | FileData>

  /**
   * List of paths to exclude (glob patterns)
   */
  exclude?: string[]

  /**
   * List of paths to include (glob patterns, including condition replacements)
   *
   * - By default, all dat/dll/sc4desc/sc4lot/sc4model files are included.
   * - If specified, *only* the provided paths are included.
   */
  include?: Array<string | FileData>

  /**
   * Asset ID
   */
  id: AssetID
}

function loadVariantAssetInfo(data: VariantAssetData | AssetID): VariantAssetInfo {
  if (isString(data)) {
    return { id: data }
  }

  return {
    cleanitol: data.cleanitol?.map(toPosix),
    docs: data.docs?.map(file => {
      if (isString(file)) {
        return { path: toPosix(file) }
      }

      return { ...file, path: toPosix(file.path) }
    }),
    exclude: data.exclude?.map(toPosix),
    id: data.id,
    include: data.include?.map(file => {
      if (isString(file)) {
        return { path: toPosix(file) }
      }

      return { ...file, path: toPosix(file.path) }
    }),
  }
}

function loadDependencyInfo(data: DependencyData | PackageID): DependencyInfo {
  if (isString(data)) {
    return { id: data, transitive: true }
  }

  return {
    ...data,
    include: data.include?.map(toPosix),
    transitive: data.transitive ?? !data.include,
  }
}

/**
 * Loads a variant from a package configuration.
 */
export function loadVariantInfo(
  packageId: PackageID,
  variantId: VariantID,
  packageData: PackageData,
  categories: Categories,
): VariantInfo {
  const variantData = packageData.variants?.[variantId] ?? {}

  const ownerId = getOwnerId(packageId)
  const category = variantData.category ?? packageData.category ?? CategoryID.MODS
  const subcategories = loadCategories(category, categories)
  const priorities = subcategories.map(categoryId => categories[categoryId]?.priority ?? 0)
  const priority = Math.max(...priorities)

  const authors = unique([
    ownerId,
    ...parseStringArray(packageData.authors ?? []),
    ...parseStringArray(variantData.authors ?? []),
  ] as AuthorID[])

  const credits: VariantInfo["credits"] = {
    ...generate(authors, authorId => [authorId, null]),
    [ownerId]: "Original author",
    ...packageData.credits,
    ...variantData.credits,
  }

  const variantInfo: VariantInfo = {
    authors,
    categories: subcategories,
    credits,
    id: variantId,
    name: variantData.name ?? variantId,
    priority,
    version: variantData.version ?? packageData.version ?? "0.0.0",
  }

  const assets = unionBy(
    variantData.assets?.map(loadVariantAssetInfo) ?? [],
    packageData.assets?.map(loadVariantAssetInfo) ?? [],
    asset => asset.id,
  )

  if (assets.length) {
    variantInfo.assets = assets
  }

  const buildingFamilies = mapValues(
    {
      ...packageData.buildingFamilies,
      ...mapValues(variantData.buildingFamilies ?? {}, (families, file) => ({
        ...packageData.buildingFamilies?.[file],
        ...families,
      })),
    },
    (families, file) => mapValues(families, (data, id) => loadFamilyInfo(file, id, data)),
  )

  if (!isEmpty(buildingFamilies)) {
    variantInfo.buildingFamilies = buildingFamilies
  }

  const buildings = mapValues(
    {
      ...packageData.buildings,
      ...mapValues(variantData.buildings ?? {}, (buildings, file) => ({
        ...packageData.buildings?.[file],
        ...buildings,
      })),
    },
    (buildings, file) =>
      mapValues(buildings, (data, id) => loadBuildingInfo(file, id, data, categories)),
  )

  if (!isEmpty(buildings)) {
    variantInfo.buildings = buildings
  }

  const dependencies = unionBy(
    variantData.dependencies?.map(loadDependencyInfo) ?? [],
    packageData.dependencies?.map(loadDependencyInfo) ?? [],
    dependency => dependency.id,
  )

  if (dependencies.length) {
    variantInfo.dependencies = dependencies
  }

  const deprecated = variantData.deprecated ?? packageData.deprecated

  if (deprecated) {
    variantInfo.deprecated = deprecated
  }

  const description = variantData.description ?? packageData.description

  if (description) {
    variantInfo.description = description
  }

  const experimental = variantData.experimental ?? packageData.experimental

  if (experimental) {
    variantInfo.experimental = experimental
  }

  const files = unionBy(variantData.files ?? [], packageData.files ?? [], file => file.path)

  if (files.length) {
    variantInfo.files = files.map(file => ({ ...file, path: toPosix(file.path) }))
  }

  const images = union(variantData.images ?? [], packageData.images ?? [])

  if (images.length) {
    variantInfo.images = images
  }

  const logs = variantData.logs ?? packageData.logs

  if (logs) {
    variantInfo.logs = logs
  }

  const lots = mapValues(
    {
      ...packageData.lots,
      ...mapValues(variantData.lots ?? {}, (lots, file) => ({
        ...packageData.lots?.[file],
        ...lots,
      })),
    },
    (lots, file) => mapValues(lots, (data, id) => loadLotInfo(file, id, data)),
  )

  if (!isEmpty(lots)) {
    variantInfo.lots = lots
  }

  const mmps = unionBy(variantData.mmps ?? [], packageData.mmps ?? [], mmp => mmp.id)

  if (mmps.length) {
    variantInfo.mmps = mmps.map(mmp =>
      mmp.category ? { categories: loadCategories(mmp.category, categories), ...mmp } : mmp,
    )
  }

  const optionalDependencies = union(variantData.optional ?? [], packageData.optional ?? [])

  if (optionalDependencies.length) {
    variantInfo.optional = optionalDependencies
  }

  const options = unionBy(
    mapDefined(variantData.options ?? [], loadOptionInfo),
    mapDefined(packageData.options ?? [], loadOptionInfo),
    option => option.id,
  )

  if (options.length) {
    variantInfo.options = options
  }

  const propFamilies = mapValues(
    {
      ...packageData.propFamilies,
      ...mapValues(variantData.propFamilies ?? {}, (families, file) => ({
        ...packageData.propFamilies?.[file],
        ...families,
      })),
    },
    (families, file) => mapValues(families, (data, id) => loadFamilyInfo(file, id, data)),
  )

  if (!isEmpty(propFamilies)) {
    variantInfo.propFamilies = propFamilies
  }

  const props = mapValues(
    {
      ...packageData.props,
      ...mapValues(variantData.props ?? {}, (props, file) => ({
        ...packageData.props?.[file],
        ...props,
      })),
    },
    (props, file) => mapValues(props, (data, id) => loadPropInfo(file, id, data)),
  )

  if (!isEmpty(props)) {
    variantInfo.props = props
  }

  const readme = variantData.readme ?? packageData.readme

  if (readme) {
    variantInfo.readme = readme
  }

  const release = variantData.release ?? packageData.release

  if (release) {
    variantInfo.release = new Date(release).toISOString()
  }

  if (isNew(variantInfo)) {
    variantInfo.new = true
  }

  const repository = variantData.repository ?? packageData.repository

  if (repository) {
    variantInfo.repository = repository
  }

  const requirements = { ...packageData.requirements, ...variantData.requirements }

  if (!isEmpty(requirements)) {
    variantInfo.requirements = requirements
  }

  const summary = variantData.summary ?? packageData.summary

  if (summary) {
    variantInfo.summary = summary
  }

  const support = variantData.support ?? packageData.support

  if (support) {
    variantInfo.support = support
  }

  const thumbnail = variantData.thumbnail ?? packageData.thumbnail

  if (thumbnail) {
    variantInfo.thumbnail = thumbnail
  }

  const url = variantData.url ?? packageData.url

  if (url) {
    variantInfo.url = url
  }

  const warnings = union(variantData.warnings ?? [], packageData.warnings ?? [])

  if (warnings.length) {
    variantInfo.warnings = warnings
  }

  return variantInfo
}
