import type { AssetID } from "@common/assets"
import type { AuthorID } from "@common/authors"
import type { TGI } from "@common/dbpf"
import type { ExemplarDataPatch } from "@common/exemplars"
import type { Requirements } from "@common/options"
import { type PackageID, getOwnerId, isNew } from "@common/packages"
import type { PackageWarning } from "@common/types"
import type { MaybeArray } from "@common/utils/types"
import type { DependencyInfo, VariantAssetInfo, VariantID, VariantInfo } from "@common/variants"
import { type BuildingData, loadBuildingInfo, writeBuildingInfo } from "./buildings"
import { type FamilyData, loadFamilyInfo, writeFamilyInfo } from "./families"
import { type LotData, loadLotInfo, writeLotInfo } from "./lots"
import { type OptionData, loadOptionInfo } from "./options"
import { type PropData, loadPropInfo, writePropInfo } from "./props"

import type { BuildingID } from "@common/buildings"
import type { Categories } from "@common/categories"
import type { FamilyID } from "@common/families"
import type { LotID } from "@common/lots"
import type { FloraID } from "@common/mmps"
import type { PropID } from "@common/props"
import { toPosix } from "@node/files"
import { isEmpty, isString, mapDefined, mapValues, union, unionBy } from "@salinco/nice-utils"
import type { AssetData } from "./assets"
import { loadAuthors } from "./authors"
import { getPriority, loadCategories } from "./categories"
import { type FloraData, loadFloraInfo, writeFloraInfo } from "./mmps"
import type { PackageData } from "./packages"

/**
 * Raw variant data, as stored in YAML files
 *
 * Once published, this should be kept backward-compatible.
 */
export interface VariantData extends ContentsData {
  /**
   * List of required assets (and additional details about included files)
   *
   * Only on remote packages.
   */
  assets?: Array<AssetID | VariantAssetData>

  /**
   * List of additional authors (array or comma-separated string, case-insensitive)
   *
   * - Owner of package is always implicitly tagged as first author (cannot be overridden)
   * - Package will appear in the package listing of all tagged authors
   * - Order matters (tags will be in the same order)
   * - Note that this is independent from {@link credits} and {@link thanks}
   */
  authors?: MaybeArray<string>

  /**
   * List of categories (array or comma-separated string, case-insensitive)
   *
   * - Some categories may implicitly add others
   * - Order matters (tags will be in the same order)
   */
  categories?: MaybeArray<string>

  /**
   * @deprecated
   */
  category?: MaybeArray<string>

  /**
   * List of credits, where each line is either:
   * - An {@link AuthorID}
   * - An arbitrary text
   * - An object of format `authorId: "arbitrary text"`
   *
   * This does not affect filters or author listing - use {@link tags} instead/additionally.
   */
  credits?: Array<AuthorID | string | { [authorId in AuthorID]: string }>

  /**
   * List of required dependencies
   *
   * - These packages **must not** contain `features` (use {@link requirements} instead)
   * - Dependency on a specific variant is **not** supported
   * - Partial dependencies are supported
   */
  dependencies?: Array<PackageID | DependencyInfo>

  /**
   * Whether this package or variant is experimental (e.g. test version)
   */
  deprecated?: boolean | PackageID

  /**
   * Full description in Markdown format
   *
   * The following sections should not be included in the description:
   *   - greetings (the top of the description is most visible part so it should be informative)
   *   - {@link name} (redundant)
   *   - {@link credits}
   *   - {@link dependencies}
   *   - {@link optional} dependencies
   *   - {@link thanks}
   *   - listing or detailed stats of {@link lots}, {@link props}...
   *   - compatibility information redundant with {@link requirements}
   *   - installation/uninstallation instructions redundant with {@link warnings}
   *   - redirections to included {@link readme} file, {@link support} thread, or Git {@link repository}
   */
  description?: string

  /**
   * Whether this package or variant should be hidden in Manager (e.g. work in progress)
   */
  disabled?: boolean

  /**
   * Whether this package or variant is experimental (e.g. test version)
   */
  experimental?: boolean

  /**
   * List of installed files
   *
   * Only on installed/local packages.
   */
  files?: FileData[]

  /**
   * List of image URLs
   */
  images?: string[]

  /**
   * Date or ISO string at which this variant was last generated/updated by the Indexer (used by Indexer only)
   */
  lastGenerated?: Date | string

  /**
   * Date or ISO string at which this variant was last modified/uploaded, as specified on its download page
   */
  lastModified?: Date | string

  /**
   * Name of the .log file generated by this variant's DLL, if any
   */
  logs?: string

  /**
   * Pretty name for this variant
   */
  name?: string

  /**
   * List of optional dependencies
   *
   * - Contrary to {@link dependencies}, these packages may contain `features`
   */
  optional?: PackageID[]

  /**
   * List of options
   */
  options?: OptionData[]

  /**
   * Relative path to the main Readme file (the one that is shown in Readme tab)
   */
  readme?: string

  /**
   * Date or ISO string at which this variant was first added to the Manager database (used to mark "new" packages)
   */
  release?: Date | string

  /**
   * URL to this package's source code repository
   */
  repository?: string

  /**
   * Compatibility requirements for this variant
   *
   * The possible requirements are:
   * - Features (must be present or not, e.g. `cam` or `darknite`)
   * - Minimum game version (e.g. `minVersion: 638`)
   * - Global options
   */
  requirements?: Requirements

  /**
   * Shorter description, containing no line breaks or formatting, displayed instead of {@link description} when space is limited (e.g. package listing)
   */
  summary?: string

  /**
   * URL to a plugin/support thread
   */
  support?: string

  /**
   * List of credits, where each line is either:
   * - An {@link AuthorID}
   * - An arbitrary text
   * - An object of format `authorId: "arbitrary text"`
   */
  thanks?: Array<AuthorID | string | { [authorId in AuthorID]: string }>

  /**
   * URL to a thumbnail
   */
  thumbnail?: string

  /**
   * URL to this package's main download page
   */
  url?: string

  /**
   * Valid semver version (x.x.x)
   */
  version?: string

  /**
   * Warnings
   */
  warnings?: PackageWarning[]
}

export interface ContentsData {
  /**
   * Included building family exemplars, grouped by file and instance ID
   */
  buildingFamilies?: {
    [path in string]?: {
      [familyId in FamilyID]?: FamilyData
    }
  }

  /**
   * Included building exemplars, grouped by file and instance ID
   */
  buildings?: {
    [path in string]?: {
      [instanceId in BuildingID]?: BuildingData
    }
  }

  /**
   * Included lot exemplars, grouped by file and instance ID
   */
  lots?: {
    [path in string]?: {
      [instanceId in LotID]?: LotData
    }
  }

  /**
   * Included flora exemplars, grouped by file and instance ID
   */
  mmps?: {
    [path in string]?: {
      [instanceId in FloraID]?: FloraData
    }
  }

  /**
   * Included S3D model IDs, grouped by file
   */
  models?: {
    [path in string]?: string[]
  }

  /**
   * Included prop family exemplars, grouped by file and instance ID
   */
  propFamilies?: {
    [path in string]?: {
      [familyId in FamilyID]?: FamilyData
    }
  }

  /**
   * Included prop exemplars, grouped by file and instance ID
   */
  props?: {
    [path in string]?: {
      [instanceId in PropID]?: PropData
    }
  }

  /**
   * Included FSH texture IDs, grouped by file
   */
  textures?: {
    [path in string]?: string[]
  }
}

export interface DependencyData {
  /**
   * Package ID
   */
  id: PackageID

  /**
   * Paths to include (glob patterns)
   *
   * This can be used if only a single file of a big package is needed.
   *
   * By default, the whole package is included.
   */
  include?: string[]

  /**
   * Whether to include this dependency's dependencies, recursively
   *
   * Defaults to `true` unless {@link include} is specified.
   */
  transitive?: boolean
}

export interface FileData {
  /**
   * Mapping to a new path upon installation
   *
   * Only on remote packages.
   */
  as?: string

  /**
   * Conditions for this file to be included
   */
  condition?: Requirements

  /**
   *
   * Only on installed packages.
   */
  patches?: {
    [entryId in TGI]?: ExemplarDataPatch
  }

  /**
   * Relative path
   *
   * - For remote packages, this may be a glob pattern, including condition replacements
   * - For installed packages, this must be an exact path (POSIX preferred but not required)
   */
  path: string

  /**
   * If this file should have a higher priority than the rest of the package, overwrite here.
   *
   * - Priority of 900 or higher is treated as "override"
   */
  priority?: number
}

export interface VariantAssetData extends AssetData {
  /**
   * List of cleanitol paths (glob patterns)
   *
   * - By default, all txt files with containing "cleanitol" are included.
   * - If specified, *only* the provided paths are included.
   */
  cleanitol?: string[]

  /**
   * List of documentation paths (glob patterns)
   *
   * - By default, all txt/pdf/html/css and image files are included.
   * - If specified, *only* the provided paths are included.
   */
  docs?: Array<string | FileData>

  /**
   * List of paths to exclude (glob patterns)
   */
  exclude?: string[]

  /**
   * List of paths to include (glob patterns, including condition replacements)
   *
   * - By default, all dat/dll/sc4desc/sc4lot/sc4model files are included.
   * - If specified, *only* the provided paths are included.
   */
  include?: Array<string | FileData>

  /**
   * Asset ID
   */
  id: AssetID
}

function loadVariantAssetInfo(data: VariantAssetData | AssetID): VariantAssetInfo {
  if (isString(data)) {
    return { id: data }
  }

  return {
    cleanitol: data.cleanitol?.map(toPosix),
    docs: data.docs?.map(file => {
      if (isString(file)) {
        return { path: toPosix(file) }
      }

      return { ...file, path: toPosix(file.path) }
    }),
    exclude: data.exclude?.map(toPosix),
    id: data.id,
    include: data.include?.map(file => {
      if (isString(file)) {
        return { path: toPosix(file) }
      }

      return { ...file, path: toPosix(file.path) }
    }),
  }
}

function loadDependencyInfo(data: DependencyData | PackageID): DependencyInfo {
  if (isString(data)) {
    return { id: data, transitive: true }
  }

  return {
    ...data,
    include: data.include?.map(toPosix),
    transitive: data.transitive ?? !data.include,
  }
}

export function loadVariantInfo(
  packageId: PackageID,
  variantId: VariantID,
  packageData: PackageData,
  categories: Categories,
): VariantInfo {
  const variantData = packageData.variants?.[variantId] ?? {}

  const ownerId = getOwnerId(packageId)

  const packageAuthors = loadAuthors(packageData.authors ?? [], ownerId)
  const variantAuthors = loadAuthors(variantData.authors ?? [], ownerId)
  const mergedAuthors = union(packageAuthors, variantAuthors)

  const packageCategories = loadCategories(packageData.categories ?? [], categories)
  const variantCategories = loadCategories(variantData.categories ?? [], categories)
  const mergedCategories = union(packageCategories, variantCategories)

  const variantInfo: VariantInfo = {
    authors: mergedAuthors,
    categories: mergedCategories,
    id: variantId,
    name: variantData.name ?? variantId,
    priority: getPriority(mergedCategories, categories),
    version: variantData.version ?? packageData.version ?? "0.0.0",
  }

  const assets = unionBy(
    variantData.assets?.map(loadVariantAssetInfo) ?? [],
    packageData.assets?.map(loadVariantAssetInfo) ?? [],
    asset => asset.id,
  )

  if (assets.length) {
    variantInfo.assets = assets
  }

  const buildingFamilies = mapValues(
    {
      ...packageData.buildingFamilies,
      ...mapValues(variantData.buildingFamilies ?? {}, (families, file) => ({
        ...packageData.buildingFamilies?.[file],
        ...families,
      })),
    },
    (families, file) => mapValues(families, (data, id) => loadFamilyInfo(file, id, data)),
  )

  if (!isEmpty(buildingFamilies)) {
    variantInfo.buildingFamilies = buildingFamilies
  }

  const buildings = mapValues(
    {
      ...packageData.buildings,
      ...mapValues(variantData.buildings ?? {}, (buildings, file) => ({
        ...packageData.buildings?.[file],
        ...buildings,
      })),
    },
    (buildings, file) =>
      mapValues(buildings, (data, id) => loadBuildingInfo(file, id, data, categories)),
  )

  if (!isEmpty(buildings)) {
    variantInfo.buildings = buildings
  }

  const credits = unionBy(
    loadCredits(variantData.credits ?? []),
    loadCredits(packageData.credits ?? []),
    credit => credit.id ?? credit.text,
  )

  if (credits.length) {
    variantInfo.credits = credits
  }

  const dependencies = unionBy(
    variantData.dependencies?.map(loadDependencyInfo) ?? [],
    packageData.dependencies?.map(loadDependencyInfo) ?? [],
    dependency => dependency.id,
  )

  if (dependencies.length) {
    variantInfo.dependencies = dependencies
  }

  const deprecated = variantData.deprecated ?? packageData.deprecated

  if (deprecated) {
    variantInfo.deprecated = deprecated
  }

  const description = variantData.description ?? packageData.description

  if (description) {
    variantInfo.description = description
  }

  const experimental = variantData.experimental ?? packageData.experimental

  if (experimental) {
    variantInfo.experimental = experimental
  }

  const files = unionBy(variantData.files ?? [], packageData.files ?? [], file => file.path)

  if (files.length) {
    variantInfo.files = files.map(file => ({ ...file, path: toPosix(file.path) }))
  }

  const images = union(variantData.images ?? [], packageData.images ?? [])

  if (images.length) {
    variantInfo.images = images
  }

  const logs = variantData.logs ?? packageData.logs

  if (logs) {
    variantInfo.logs = logs
  }

  const lots = mapValues(
    {
      ...packageData.lots,
      ...mapValues(variantData.lots ?? {}, (lots, file) => ({
        ...packageData.lots?.[file],
        ...lots,
      })),
    },
    (lots, file) => mapValues(lots, (data, id) => loadLotInfo(file, id, data)),
  )

  if (!isEmpty(lots)) {
    variantInfo.lots = lots
  }

  const mmps = mapValues(
    {
      ...packageData.mmps,
      ...mapValues(variantData.mmps ?? {}, (mmps, file) => ({
        ...packageData.mmps?.[file],
        ...mmps,
      })),
    },
    (mmps, file) => mapValues(mmps, (data, id) => loadFloraInfo(file, id, data)),
  )

  if (!isEmpty(mmps)) {
    variantInfo.mmps = mmps
  }

  const optionalDependencies = union(variantData.optional ?? [], packageData.optional ?? [])

  if (optionalDependencies.length) {
    variantInfo.optional = optionalDependencies
  }

  const options = unionBy(
    mapDefined(variantData.options ?? [], loadOptionInfo),
    mapDefined(packageData.options ?? [], loadOptionInfo),
    option => option.id,
  )

  if (options.length) {
    variantInfo.options = options
  }

  const propFamilies = mapValues(
    {
      ...packageData.propFamilies,
      ...mapValues(variantData.propFamilies ?? {}, (families, file) => ({
        ...packageData.propFamilies?.[file],
        ...families,
      })),
    },
    (families, file) => mapValues(families, (data, id) => loadFamilyInfo(file, id, data)),
  )

  if (!isEmpty(propFamilies)) {
    variantInfo.propFamilies = propFamilies
  }

  const props = mapValues(
    {
      ...packageData.props,
      ...mapValues(variantData.props ?? {}, (props, file) => ({
        ...packageData.props?.[file],
        ...props,
      })),
    },
    (props, file) => mapValues(props, (data, id) => loadPropInfo(file, id, data)),
  )

  if (!isEmpty(props)) {
    variantInfo.props = props
  }

  const readme = variantData.readme ?? packageData.readme

  if (readme) {
    variantInfo.readme = readme
  }

  const release = variantData.release ?? packageData.release

  if (release) {
    variantInfo.release = new Date(release).toISOString()
  }

  if (isNew(variantInfo)) {
    variantInfo.new = true
  }

  const repository = variantData.repository ?? packageData.repository

  if (repository) {
    variantInfo.repository = repository
  }

  const requirements = { ...packageData.requirements, ...variantData.requirements }

  if (!isEmpty(requirements)) {
    variantInfo.requirements = requirements
  }

  const summary = variantData.summary ?? packageData.summary

  if (summary) {
    variantInfo.summary = summary
  }

  const support = variantData.support ?? packageData.support

  if (support) {
    variantInfo.support = support
  }

  const thanks = unionBy(
    loadCredits(variantData.thanks ?? []),
    loadCredits(packageData.thanks ?? []),
    thank => thank.id ?? thank.text,
  )

  if (thanks.length) {
    variantInfo.thanks = thanks
  }

  const thumbnail = variantData.thumbnail ?? packageData.thumbnail

  if (thumbnail) {
    variantInfo.thumbnail = thumbnail
  }

  const url = variantData.url ?? packageData.url

  if (url) {
    variantInfo.url = url
  }

  const warnings = union(variantData.warnings ?? [], packageData.warnings ?? [])

  if (warnings.length) {
    variantInfo.warnings = warnings
  }

  return variantInfo
}

export function writeVariantInfo(variantInfo: VariantInfo): VariantData {
  return {
    authors: variantInfo.authors,
    buildingFamilies: variantInfo.buildingFamilies
      ? mapValues(variantInfo.buildingFamilies, families => mapValues(families, writeFamilyInfo))
      : undefined,
    buildings: variantInfo.buildings
      ? mapValues(variantInfo.buildings, buildings => mapValues(buildings, writeBuildingInfo))
      : undefined,
    category: variantInfo.categories.join(","),
    credits: variantInfo.credits?.length ? writeCredits(variantInfo.credits) : undefined,
    dependencies: variantInfo.dependencies?.length ? variantInfo.dependencies : undefined,
    deprecated: variantInfo.deprecated,
    description: variantInfo.description,
    experimental: variantInfo.experimental,
    files: variantInfo.files,
    images: variantInfo.images,
    lastModified: variantInfo.lastModified ? new Date(variantInfo.lastModified) : undefined,
    logs: variantInfo.logs,
    lots: variantInfo.lots
      ? mapValues(variantInfo.lots, lots => mapValues(lots, writeLotInfo))
      : undefined,
    mmps: variantInfo.mmps
      ? mapValues(variantInfo.mmps, mmps => mapValues(mmps, writeFloraInfo))
      : undefined,
    name: variantInfo.name,
    optional: variantInfo.optional,
    options: variantInfo.options,
    propFamilies: variantInfo.propFamilies
      ? mapValues(variantInfo.propFamilies, families => mapValues(families, writeFamilyInfo))
      : undefined,
    props: variantInfo.props
      ? mapValues(variantInfo.props, props => mapValues(props, writePropInfo))
      : undefined,
    readme: variantInfo.readme,
    release: variantInfo.release ? new Date(variantInfo.release) : undefined,
    repository: variantInfo.repository,
    requirements: variantInfo.requirements,
    summary: variantInfo.summary,
    support: variantInfo.support,
    thanks: variantInfo.thanks?.length ? writeCredits(variantInfo.thanks) : undefined,
    thumbnail: variantInfo.thumbnail,
    url: variantInfo.url,
    version: variantInfo.version,
    warnings: variantInfo.warnings,
  }
}

export function loadCredits(
  credits: Array<AuthorID | string | { [authorId in AuthorID]: string }>,
): { id?: AuthorID; text?: string }[] {
  return credits.flatMap<{ id?: AuthorID; text?: string }>(credit => {
    if (isString(credit)) {
      if (credit.match(/^\S+$/)) {
        return [{ id: credit.toLowerCase() as AuthorID }]
      }

      return [{ text: credit }]
    }

    return Object.entries(credit).map(([id, text]) => ({ id: id.toLowerCase() as AuthorID, text }))
  })
}

function writeCredits(
  credits: { id?: AuthorID; text?: string }[],
): Array<AuthorID | string | { [authorId in AuthorID]: string }> {
  return mapDefined(credits, credit => {
    if (credit.id && credit.text) {
      return { [credit.id]: credit.text }
    }

    return credit.id ?? credit.text
  })
}
